# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.

'''
Splitters and user/affinity matrix generation utilities

'''

import pandas as pd

import numpy as np
import random
import math

from scipy.sparse import coo_matrix

from reco_utils.common.constants import (
    DEFAULT_ITEM_COL,
    DEFAULT_USER_COL,
    DEFAULT_TIMESTAMP_COL,
)

from reco_utils.dataset.split_utils import (
    process_split_ratio,
    min_rating_filter_pandas,
    split_pandas_data_with_ratios,
)



#========================================================
#Generate the User/Item affinity matrix from a pandas DF
#========================================================


def gen_index(self, DF):

    '''
    Generate the user/item index

    Args:
        DF: a dataframe containing the data

    Returns:
        map_users, map_items: dictionaries mapping the original user/item index to matrix indices
        map_back_users, map_back_items: dictionaries to map back the matrix elements to the original
                                        dataframe indices

    Basic mechanics:
        As a first step we retieve the unique elements in the dataset. In this way we can take care
        of either completely missing rows (a user with no ratings) or completely missing columns
        (an item that has not being reviewed by anyone). The original indices in the dataframe are
        then mapped to an ordered, contiguous integer series to generate a compact matrix representation.

        Functions to map back to the original indices are also provided and can be saved in order to use
        a pretrained model.

    '''
    #sort entries by user index
    df = DF.sort_values(by=[self.col_user])

    #find unique user and item index
    unique_users = df[self.col_user].unique()
    unique_items = df[self.col_item].unique()


    #create a dictionary to map unique users/items to hashed values to generate the matrix
    self.map_users = {x:i for i, x in enumerate(unique_users)}
    self.map_items = {x:i for i, x in enumerate(unique_items)}

    #map back functions used to get back the original dataframe
    self.map_back_users = {i:x for i, x in enumerate(unique_users)}
    self.map_back_items = {i:x for i, x in enumerate(unique_items)}

    #optionally save the inverse dictionary to work with trained models
    if self.save_model_:
        np.save(self.save_path_ + '/user_dict', self.map_users)
        np.save(self.save_path_ + '/item_dict', self.map_items)

        np.save(self.save_path_ + '/user_back_dict', self.map_back_users)
        np.save(self.save_path_ + '/item_back_dict', self.map_back_items)



def gen_affinity_matrix(self, DF):

    '''
    Generate the user/item affinity matrix

    Args:
        DF: A dataframe containing at least UserID, ItemID, Ratings

    Returns:
        RM: user-affinity matrix of dimensions (Nusers, Nitems) in numpy format. Unrated movies
        are assigned a value of 0.

    Basic mechanics:
        As a firts step, two new columns are added to the input DF, containing the index maps
        generated by the gen_index() method. The Dnew indices, together with the ratings, are
        then used to generate the user/item affinity matrix using scipy's sparse matrix method
        coo_matrix; for reference see

        https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html

        The input format is coo_matrix((data, (rows, columns)), shape=(rows, columns))

    '''
    df = DF.copy()

    log.info("Generating the user/item affinity matrix...")

    df.loc[:, 'hashedItems'] = df[self.col_item].map(self.map_items)
    df.loc[:, 'hashedUsers'] = df[self.col_user].map(self.map_users)

    #extract informations from the dataframe as an array. Note that we substract 1 from itm_id and usr_id
    #in order to map it to matrix format

    r_ = df[self.col_rating]    #ratings
    itm_id = df['hashedItems']  #itm_id serving as columns
    usr_id = df['hashedUsers']  #usr_id serving as rows

    #check that all 3 vectors have the same dimensions
    assert((usr_id.shape[0]== r_.shape[0]) & (itm_id.shape[0] == r_.shape[0]))

    #generate a sparse matrix representation using scipy's coo_matrix and convert to array format
    RM = sparse.coo_matrix((r_, (usr_id, itm_id)), shape= (self.Nusers, self.Nitems)).toarray()

    #---------------------print the degree of sparsness of the matrix------------------------------

    zero   = (RM == 0).sum() # number of unrated items
    total  = RM.shape[0]*RM.shape[1] #number of elements in the matrix
    sparsness = zero/total *100 #Percentage of zeros in the matrix

    print('Matrix generated, sparsness %d' %sparsness,'%')

    return RM
